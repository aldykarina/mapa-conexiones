<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mapa de Conexiones — Mapa</title>
  <style>
    :root {
      --gap: 12px;  font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
        /* Fondos */
      --bg-1: #f8f8f9;     /* fondo general */
      --bg-2: #ffffff;     /* fondo de tarjetas o paneles */
      --bg-3: #f01717;     /* fondo destacado */

      /* Textos */
      --text-1: #333333;   /* texto principal */
      --text-2: #777777;   /* texto secundario o hints */
      --text-3: #ffffff;   /* texto sobre fondo oscuro */
    }
    html, body { height: 100%; margin: 0; }
    body { display: flex; flex-direction: column; background: var(--bg-1); }

    /* --- CAMBIO: Header ocupa todo el ancho */
    .header {
      display: flex;
      align-items: center;
      justify-content: center;  /*centramos contenido --- */
      padding: 10px 16px;
      border-bottom: 1px solid #eee;
      background: var(--bg-3);
      color: #fff;
      font-weight: bold;
      position: relative; /*  para ubicar menú a la derecha --- */
      z-index: 10; 
    }
    .header h1 {
      margin: 0;
      font-size: 24px;
      text-align: center; /* --- CAMBIO NUEVO: centrado --- */
      flex: 1;            /* --- CAMBIO NUEVO: ocupar ancho para mantener centrado --- */
    }

    button {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      font-size: 14px;
    }

    /*#cy {       flex: 1;      background: #fff;      position: relative;      overflow: hidden;    }*/
    #cy{ flex:1; border-left:1px solid #eaeaea;
      background-color: #fff;   /*Dentro del mapa*/
      position: relative;
      z-index: 1;
      overflow: hidden;
    }
    #cy::before {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background-image: url('img/fondo-cy.png'); /*imagen */
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      opacity: 0.5;
      z-index: 0;
      pointer-events: none; /* evita que bloquee clics en el grafo */
    }

    .footer {
      background-color: var(--bg-3);
      color: #fff;
      text-align: center;
      padding: 12px;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 -2px 6px rgba(0,0,0,0.2);
    }
    .menu-container {
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 20;
    }
    .menu-toggle {
      background: #fff;
      color: var(--bg-3);
      font-size: 18px;
      padding: 6px 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .menu-content {
      display: none;
      position: absolute;
      right: 0;
      background: white;
      min-width: 160px;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0px 8px 16px rgba(0,0,0,0.2);
      z-index: 30;
    }
    .menu-content button {
      background: none;
      border: none;
      padding: 10px;
      width: 100%;
      text-align: left;
      cursor: pointer;
    }
    .menu-content button:hover {
      background: #f1f1f1;
    }

  </style>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
</head>
<body>
  <!--Header con título y menú hamburguesa -->
  <header class="header">
    <h1>MAPA DE CONEXIONES</h1>
    <!-- --- Menú hamburguesa con botones --- -->
    <div class="menu-container">
      <button class="menu-toggle">☰</button>
      <div class="menu-content">
        <button id="btnConectate">Conéctate aquí</button>
        <button id="btnExportMap">Exportar Mapa</button>
      </div>
    </div>
  </header>

  <!-- CAMBIO: Mapa ocupa todo el espacio -->
  <main style="flex:1; display:flex; flex-direction:column">
    <div id="cy"></div>
  </main>

  <footer class="footer">Juntos conectados</footer>

  <script>
    const PEOPLE_JSON = './people_example20.json';
    const LS_KEY = 'mapaConexiones_v1';
    let shuffleTimer = null;

    let state = { people: [], connections: {} };

    // helpers
    function loadAll(){ const s = localStorage.getItem(LS_KEY); return s ? JSON.parse(s) : null }

    // Cytoscape init (solo vista)
    const getVar = (v) => getComputedStyle(document.documentElement).getPropertyValue(v).trim();

    const cy = cytoscape({
      container: document.getElementById('cy'),
      elements: [],
      style: [
        { selector: 'node', style: {
            'label': 'data(label)',
            'text-valign': 'bottom',
            'text-margin-y': 4,
            'background-fit': 'cover',
            'background-image': 'data(img)',
            'border-color':getVar('--bg-3'),
            'border-width':1.5,
            'width': 50,
            'height':50,
            'font-size':10
        }},
        { selector: 'edge', style: { 'width': 1.5, 'line-color': getVar('--bg-3')}},
      ],
      layout: { name: 'cose', animate: true }
    });

    async function fetchPeople(){
      try{
        const res = await fetch(PEOPLE_JSON);
        const js = await res.json();
        return js.map((p,i)=>({
          id: p.id?.toString() || 'p'+(i+1),
          name: p.name||'',
          last: p.last||'',
          img: p.img||''
        }));
      }catch(e){
        console.warn('No se pudo cargar JSON:', e);
        return [];
      }
    }

    function buildElements(){
      const nodes = state.people.map(p=>({ data: { id: p.id, img: p.img }}));
      //const nodes = state.people.map(p=>({ data: { id: p.id, label: p.name+' '+(p.last||''), img: p.img }}));
      const edges = [];
      for(const from in state.connections){
        for(const to in state.connections[from]){
          edges.push({ data: { id: from+'_'+to, source: from, target: to }});
        }
      }
      return { nodes, edges };
    }
    // REFRESCAR GRAFICO
    
    
    // REEMPLAZA tu función refreshGraph por esta versión:
    function refreshGraph(autoMove = false){
      const elems = buildElements();
      cy.elements().remove();
      cy.add(elems.nodes);
      cy.add(elems.edges);

      const container = cy.container().getBoundingClientRect();
      const containerWidth = Math.max(200, container.width);
      const containerHeight = Math.max(150, container.height);

      const n = elems.nodes.length;
      if (!n) return;

      // --- elegir número de columnas basadas en la proporción del contenedor
      const aspect = containerWidth / containerHeight;
      const base = Math.ceil(Math.sqrt(n));
      const cols = 6; // Math.max(2, Math.min(n, Math.round(base * Math.min(2, Math.max(1, aspect)))));
      const rows = Math.ceil(n / cols);

      // padding interno
      const padding = 40;
      const usableW = Math.max(50, containerWidth - 2 * padding);
      const usableH = Math.max(50, containerHeight - 2 * padding);

      const cellW = usableW / cols;
      const cellH = usableH / rows;

      // Generar posiciones de la grilla
      let positions = [];
      for (let r = 0; r < rows; r++){
        for (let c = 0; c < cols; c++){
          positions.push({
            x: padding + c * cellW + cellW / 2,
            y: padding + r * cellH + cellH / 2
          });
        }
      }

      const nodes = cy.nodes();
      nodes.forEach((node, i) => {
        const pos = positions[i] || {
          x: padding + Math.random() * usableW,
          y: padding + Math.random() * usableH
        };
        node.position({ x: pos.x, y: pos.y });
      });

      // Calcular bounding box
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodes.forEach(node => {
        const p = node.position();
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      });

      const bboxW = Math.max(1, maxX - minX);
      const bboxH = Math.max(1, maxY - minY);

      // Calcular escala
      const margin = 30;
      const scaleX = (containerWidth - 2 * margin) / bboxW;
      const scaleY = (containerHeight - 2 * margin) / bboxH;
      let scale = Math.min(scaleX, scaleY);
      scale = Math.min(scale, 1);
      scale = Math.max(scale, 0.25);

      // Pan centrado
      const bboxCenterX = (minX + maxX) / 2;
      const bboxCenterY = (minY + maxY) / 2;
      const panX = containerWidth / 2 - scale * bboxCenterX;
      const panY = containerHeight / 2 - scale * bboxCenterY;

      cy.zoom(scale);
      cy.pan({ x: panX, y: panY });

      // Función que mezcla posiciones entre nodos
      function shufflePositions() {
        // Barajar posiciones (Fisher-Yates)
        let shuffled = [...positions];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }

        const jitter = 20;
        nodes.forEach((node, i) => {
          const pos = shuffled[i] || positions[i];
          node.animate({
            position: {
              x: pos.x + (Math.random() - 0.5) * jitter,
              y: pos.y + (Math.random() - 0.5) * jitter
            },
            duration: 700
          });
        });
      }

      // limpiar interval anterior
      if (shuffleTimer) {
        clearInterval(shuffleTimer);
        shuffleTimer = null;
      }

      shufflePositions(); // correr una vez

      if (autoMove) {
        shuffleTimer = setInterval(shufflePositions, 10000);
      }
    }
    /*
    function refreshGraph(){
      const elems = buildElements();
      cy.elements().remove();
      cy.add(elems.nodes);
      cy.add(elems.edges);
      cy.layout({ name:'cose', animate:true }).run();
    } */

    // react to storage changes from edit.html
    window.addEventListener('storage', (e)=>{
      if(e.key === LS_KEY){
        const persisted = JSON.parse(e.newValue || '{}');
        state.connections = persisted.connections || {};
        refreshGraph();
      }
    });

    // Exportar PNG
    /*  document.getElementById('btnExportMap').addEventListener('click', ()=>{
      const png = cy.png({ full:true, scale:2 });
      const a = document.createElement('a'); a.href = png; a.download = 'mapa-conexiones-map.jpg'; a.click();
    });  */
    // --- CAMBIO: exportar con header y footer personalizados ---
    
  document.getElementById('btnExportMap').addEventListener('click', ()=>{

    const bgColor = getVar('--bg-3');     // fondo rojo
    const textColor = getVar('--text-3'); // texto blanco
    const canvasBg = getVar('--bg-2');    // fondo general (blanco)

    const graphPng = cy.png({ full: true, scale: 2, bg: 'transparent'}); // grafo con fondo transparente
    const img = new Image();
    img.src = graphPng;

    // Cargar también la imagen de fondo
    const bgImg = new Image();
    bgImg.src = 'img/fondo-cy.png';

    Promise.all([
      new Promise(res => img.onload = res),
      new Promise(res => bgImg.onload = res)
    ]).then(()=>{

      const padding = {top: 20, right: 20, bottom: 20, left: 20 };
      const graphWidth = img.width;
      const graphHeight = img.height;
      const headerHeight = 60;
      const footerHeight = 50;

      const totalWidth = padding.left + graphWidth + padding.right;
      const totalHeight = headerHeight + padding.top + graphHeight + padding.bottom + footerHeight;

      const canvas = document.createElement('canvas');
      canvas.width = totalWidth;
      canvas.height = totalHeight;
      const ctx = canvas.getContext('2d');

      // Fondo blanco
      ctx.fillStyle = canvasBg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Header rojo
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, headerHeight);
      ctx.fillStyle = textColor;
      ctx.font = "bold 30px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Mapa de Conexiones", canvas.width / 2, headerHeight / 2);

      // --- Fondo del grafo ---
      const bgWidth = graphWidth;  // ajustar tamaño según prefieras
      const bgHeight = graphHeight;
      const bgX = padding.left;
      const bgY = headerHeight + padding.top;
      ctx.globalAlpha = 0.5; // igual que tu CSS
      ctx.drawImage(bgImg, bgX, bgY, bgWidth, bgHeight);
      ctx.globalAlpha = 1;

      // Grafo
      ctx.drawImage(img, padding.left, headerHeight + padding.top);

      // Footer
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, headerHeight + padding.top + graphHeight + padding.bottom, canvas.width, footerHeight);
      ctx.fillStyle = textColor;
      ctx.font = "bold 22px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Juntos conectados", canvas.width / 2, headerHeight + padding.top + graphHeight + padding.bottom + footerHeight / 2);

      // Descargar
      const finalPng = canvas.toDataURL("image/png");
      const a = document.createElement('a');
      a.href = finalPng;
      a.download = 'mapa-conexiones.png';
      a.click();
    });
  });


    // Conectate aquí
    document.getElementById('btnConectate').addEventListener('click', ()=>{
      // abre en la misma pestaña (puedes cambiar target si querés nueva pestaña) //window.location.href = './edit.html';
      window.open('./edit.html', '_blank');
    });

    // --- Lógica menú hamburguesa ---
    document.querySelector(".menu-toggle").addEventListener("click", () => {
      const menu = document.querySelector(".menu-content");
      menu.style.display = menu.style.display === "block" ? "none" : "block";
    });
    window.addEventListener("click", (e) => {
      if (!e.target.matches('.menu-toggle')) {
        const menu = document.querySelector(".menu-content");
        if (menu.style.display === "block") {
          menu.style.display = "none";
        }
      }
    });

    // Init
    (async function init(){
      const persisted = loadAll();
      const people = await fetchPeople();
      state.people = people;
      state.connections = persisted?.connections || {};
      refreshGraph();
    })();
  </script>
</body>
</html>
